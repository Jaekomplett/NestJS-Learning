# 1.1 NestJS 소개
NestJS는 Node.js에 기반을 둔 웹 API 프레임워크로써 Express 또는 Fastify 프레임워크를 래핑하여 동작한다. 
설치를 하게 되면 기본적으로 Express를 사용하는데 Node.js는 쉽게 사용이 가능하고 확장성도 뛰어나지만, 과도하게 유연한 성질을 갖고 있어 
소프트웨어의 품질이 일정하지 않고 알맞는 라이브러리를 찾기 위해 사용자가 많은 시간을 할애해야 한다. 

**반면에** NestJS는 데이터베이스, ORM, 설정 (Configuration), 유효성 검사 등 수많은 기능을 기본적으로 제공한다.
이와 동시에 필요한 라이브러리도 손쉽게 설치해 기능을 확장할 수 있는 Node.js의 장점도 그대로 지니고 있다.
모듈/컴포넌트 기반의 코딩이 가능해서 재사용성을 높여주고, 프로그래밍 언어로 타입스크립트를 기본으로 채택하고 있어 타입스크립트의 장점
또한 누릴 수 있다.

# 1.2 Express가 좋을까 NestJS가 좋을까?
NestJS 역시 Express를 기본으로 채택하고 그 위에 여러 기능을 미리 구현해 놓은 것이다. 그런데 왜 NestJS를 선택해야 할까?
|구분|Express|NestJS|
|-|-|-|
| 유연함, 확장성 |Express는 가볍게 테스트용 서버를 띄울수 있음. 아이디어를 빠르게 검증하는 데에는 좋겠지만 단순하고 자유도가 높은 만큼 자기에게 맞는 라이브러리를 찾기 위해 발품을 팔아야 함. 보일러 플레이트를 미리 얹어 놓은 깃허브 리포지토리들이 있으니 이를 활용해도 좋음. |미들웨어, IoC, CQRS 등 이미 많은 기능을 프레임워크 자체에 포함. 사용자는 문서를 보고 쉽게 따라할 수 있음. 원하는 기능이 없다면 다른 라이브러리를 적용해서 사용할 수 있음. |
| Typescript 지원 | 추가 설정을 통해 사용가능|기본 설정. + 바닐라 자바스크립트로도 작성 가능 |
| 커뮤니티 | 가장 큼 | 꾸준히 증가 |

인기있는 Express를 사용하는 것이 나은 선택일 수도 있지만 상용 제품을 만들기까지 시간이 오래 걸릴 수도 있다. **반면에**,
NestJS는 백엔드 서버가 갖추어야 하는 많은 필수 기능을 프레임워크 내에 내장하고 있고 추가로 필요한 기능을 설치하고 적용하는 방법을 문서로 제공한다. 
또한 DI, IoC를 채용하여 객체지향 프로그래밍과 모듈화를 쉽게 할 수 있다. Express를 사용한다면 이 모든 기능을 수행하는 패키지들을 npm에서 찾아서 검토하는 과정이 필요한데,
필요한 기능들을 하나씩 검토하고 선택하는 시간도 무시할 수 없다.

#### Node.js 기반 웹 프레임워크가 갖춰야 할 필수 기능이라면 다음과 같은 것들이 있다고 한다.

- 최신 Ecma Script 지원
- Typescript (선택사항이나 사용 추세가 계속 늘어나고 있음)
- CORS
- HTTP 헤더 보안 (Express는 helmet을 사용)
- Configuration
- Interceptor
- Middleware
- Scheduling
- Logging
- Testing
- Swagger 문서화
- ORM

NestJS 깃허브에는 PR이 제출될 때마다 Express, Fastify와의 성능을 벤치마크해서 제시하고 있다.

![image](https://user-images.githubusercontent.com/87610758/172878340-f3d185e7-29fe-487c-b3a9-1ef4d110c15c.png)


NestJS에 **Express**와 **Fastify**를 적용했을 경우를 각각 구분하고 **Express, Fastify** 자체 성능도 측정한다. 측정 결과는 NestJS가 Express의 경우는 오히려 조금 낫고 Fastify일 때는 성능이 약간 조금 떨어지는 것을 볼 수 있다. 이는 **NestJS가 기본 제공하는 프레임워크의 크기가 크기 때문**이다. 하지만 순수 Express/Fastify로 서버를 개발하다 보면 필수로 요구하는 라이브러리들을 추가하고 되고 **결국 NestJS에서 제공하는 기능들을 모두 구현한다고 했을 때 성능이 크게 차이가 나지는 않는다**.

Express는 2019년 5월 26일 최근 4.17.2, 4.17.3 버전을 업데이트하였지만 그 전까지 몇년간 개발이 정체되어 있었는데, 5.0을 준비하고 있기 때문일 수도 있고, 매우 안정적인 프레임워크라서 문제없이 운용되고 있는 것의 반증이라고 볼 수 있지만 최신 트렌드를 따라가지 못한다는 우려가 있는 것도 사실이다. NestJS는 꾸준히 발전하고 있는 모습을 보여준다. 2022년 3월에 version 8.4.0을 릴리즈하였고 깃허브를 통해 커뮤니케이션도 활발히 하고 있다.

# 1.3 NestJS 설치
### Node.js 설치
NestJS는 Node.js를 기반으로 한다. 먼저 Node.js 공식 페이지를 통해 자신에게 맞는 버전을 설치한다. 안정적인 버전인 LTS를 선택하고 다운로드 후 설치파일을 실행하거나 소스코드에서 직접 빌드 후 설치한다. (자세한 방법은 홈페이지 참조)

### NestJS 프로젝트 생성
Node.js를 설치하면 npm이 함께 설치되어 있다. npm은 Node.js에서 사용하는 패키지 관리자인데 https://www.npmjs.com/ 에 등록된 라이브러리들을 쉽게 설치, 삭제할 수 있게 해준다.

NestJS 서버를 구성하기 위해 먼저 @nestjs/cli 를 설치
```
npm i -g @nestjs/cli
```

`i` 명령어는 install 명령어의 약어이다. `-g` 옵션은 컴퓨터의 글로벌 환경에 설치하겠다는 것으로, 모든 디렉토리에서 참조 가능하다. 참고로 글로벌 환경에서 패키지가 설치되는 경로는 `npm root -g` 명령어로 확인할 수 있다.

설치가 끝났다면 프로젝트 초기 세팅을 해보자.

```
nest new project-name
```

project-name을 적당한 것으로 바꾸어 입력한다. 설치 도중 패키지 매니저를 어느 것으로 할 지 묻는데 선호하는 것으로 선택하면 된다.
<img width="682" alt="1-4" src="https://user-images.githubusercontent.com/87610758/173223171-bbfb35f0-030e-48be-bca0-00cfe5695284.png">

```
├── README.md
├── nest-cli.json
├── node_modules
├── package-lock.json
├── package.json
├── src
│   ├── app.controller.spec.ts
│   ├── app.controller.ts
│   ├── app.module.ts
│   ├── app.service.ts
│   └── main.ts
├── test
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── tsconfig.build.json
└── tsconfig.json
```

설치가 끝나면 보일러 플레이트 코드를 생성해 준다.

> https://github.com/nestjs/typescript-starter 에서 시작해도 좋다고 한다. nestjs/typescript-starter가 nest new로 프로젝트를 셋업한 것 보다 더 최신 버전의 라이브러리들로 구성해 준다.

서버를 실행하기 위해 프로젝트가 설치된 경로로 이동한 후, 아래의 명령어를 입력한다. 이 책에서는 book-nestjs-backend라는 이름으로 프로젝트를 생성하였습니다. 이 책의 소스코드는 [github 저장소](https://github.com/dextto/book-nestjs-backend)에서 다운로드 받을 수 있다.

```
git clone https://github.com/dextto/book-nestjs-backend.git
cd book-nestjs-backend/examples/ch1-intro/
npm install  // 필요한 패키지를 설치.
npm run start
```

> 운영 서버가 아닌 개발 단계에서는 npm run start:dev 명령어를 이용하라고 한다. package.json에 기술된 스크립트를 보면 "start:dev": "nest start --watch" 라고 되어 있는 걸 확인할 수 있다. —watch 옵션으로 소스코드 변경을 감지하여 코드를 저장할 때 마다 서버를 다시 구동시켜 준다. 


서버에 접속해서 잘 동작하는지 확인해 보자. 포트는 기본으로 3000번으로 설정되어 있는데, main.ts 파일에서 포트를 설정했음을 확인할 수 있다.

```ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```
# 1.4 이 책에서 만드는 애플리케이션 - 유저 서비스
이 책에서는 모든 웹 애플리케이션의 필수 기능이라고 할 수 있는 유저 서비스를 만든다.
![image](https://user-images.githubusercontent.com/87610758/173854306-42f9be20-33ff-411a-8516-a9389dcf5802.png)

유저 서비스는 다음과 같은 기능을 제공한다.

- 회원 가입화면을 통해 유저 정보(이메일, 이름, 패스워드)를 입력받아 신규 회원 가입 처리를 수행하고 회원 정보를 데이터베이스에 저장한다. 유저는 가입 준비 단계에 있게 된다.
- 회원 가입 과정에서 입력 받은 이메일로 회원 가입 확인 이메일을 전송한다. 유저는 이메일을 확인하고 회원 가입 인증을 요청한다. 이메일 본문에는 회원 가입 검증을 위한 요청으로서의 링크가 포함되어 있다. 이 링크를 통해 회원 가입 인증 요청이 들어오면 회원 가입 준비 단계에서 승인을 완료한 상태가 된다. 또 이메일 인증의 응답으로 바로 액세스 토큰(JWT)을 전달하여 로그인 상태가 되도록 한다. 이렇게 하면 사용자가 인증 후 다시 로그인 과정을 거칠 필요가 없다.
- 회원 가입 완료된 사용자가 이메일과 비밀번호로 로그인 요청을 보내면 이를 처리한다. 로그인 기능은 사실 사용자 에이전트(브라우저, 모바일 앱 등)에게 액세스 토큰(JWT)를 발급하는 것이다.
사용자는 자신의 정보를 조회할 수 있다.

서비스가 제공하는 기능은 단순하지만 이 단순한 서비스를 개발하기 위해 부가적으로 해야할 일이 많이 있다.

- **환경 변수 설정** : 서버는 여러 환경에서 실행된다. 개발자의 로컬(local) 개발환경, 개발된 기능을 실제 사용자에게 배포하기 전에 테스트용 서버에 배포하는 스테이지(stage)환경, 그리고 실제 운용하는 프로덕션(production) 환경으로 보통 구성된다. 각 환경에서 사용되는 변수가 달라지는 것들이 있다면 환경변수를 다르게 구성할 수 있도록 한다.

- **요청 유효성 검증**: 프론트엔드에서 들어오는 요청은 잘못된 값을 가지는 경우가 매우 빈번하다. 사용자가 값을 잘못 입력하기도 하고 프론트 엔드에서 걸러지지 않은 잘못된 값이 유입되는 경우도 있다. 이 경우 서버에서는 핵심 로직을 수행하기 전에 값이 제대로 전달되었는지 판단하여 만약 잘못 전달된 경우라면 400 Bad Request 에러로 응답한다. 예를 들어 로그인 요청에서 이메일을 넣어야 하는데 이메일 형식이 아닌 문자열이 전달되면 에러로 처리해야 한다.

- **인증**: 사용자의 리소스에 접근하기 위해서는 권한이 필요하고 로그인 과정을 거쳐야 한다. 로그인을 거친 유저는 매 요청마다 로그인을 할 필요는 없고 인증과정을 통해 후속 동작을 수행한다. 인증을 처리하는 방법은 여러가지가 있다. 이 책에서는 토큰방식, 그 중에서도 JWT(JSON Web Token)을 이용하는 방식을 적용한다.

- **로깅**: 서버를 운용하기 위해서는 로그를 잘 기록해야 한다. 특히 이슈가 발생했을 때 원인을 빠르고 정확하게 파악하는 데에 로그가 매우 유용하게 사용된다. 또한 사내 사용자가 무슨 동작을 수행했는지 감사로그를 남기고 외부에 기록을 제출하는 경우도 있다.

- **헬스체크**: 서버의 심장이 잘 뛰고 있는지, 즉 서버의 상태가 양호한지 주기적으로 검사한다. 만약 서버 상태가 좋지 않다면 경고를 울려서 개발자가 빠르게 대응할 수 있는 방안을 마련해야 한다.

- **CQRS(Command and Query Responsibility Segregation, 명령과 조회의 책임 분리)** : 복잡한 소프트웨어를 만들다 보면 소스 코드가 스파게티처럼 얽히게 되는 경우가 생긴다. 데이터베이스에 변형을 가하는 명령과 데이터 읽기 요청을 처리하는 조회 로직을 분리함으로써 성능, 확장성, 보안을 강화할 수 있다.
클린 아키텍처: 양파(Onion) 아키텍처, 육각형 아키텍처에서 발전한 클린 아키텍처는 SW의 계층을 분리하고 저수준의 계층이 고수준의 계층에 의존하도록 한다. 의존의 방향이 바뀌는 경우가 있다면 DIP(Dependency Inversion Principle, 의존성 역전 법칙)를 활용하여 안정적인 소프트웨어를 작성할 수 있게 해준다.

- **유닛 테스트** : 소프트웨어에 변경이 생긴다면 반드시 테스트를 해야 한다. 유닛 테스트는 유저의 입장에서 수행하는 테스트가 아닌 개발자가 테스트 코드를 이용하여 수행하는 최소 단위의 테스트 기법이다. 내가 만든 코드 조각이 동작하는 조건을 기술하고, 주어진 입력에 대해 원하는 결과가 나오는 지 검사한다.

