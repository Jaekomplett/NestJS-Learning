# 2.1 웹 프레임워크
## 2.2 Node.js
Nest는 Node.js를 기반으로 동작합니다. 정확히는 Nest로 작성한 소스코드를 Node.js 기반 프레임워크인 Express나 Fastify에서 실행 가능한 자바스크립트 소스코드로 컴파일해 주는 역할을 합니다. 따라서 Node.js의 동작원리를 이해하면 개발할 때 도움이 됩니다.

Node.js는 2009년에 릴리즈되었습니다. 그 전까지 자바스크립트는 프론트엔드에서만 사용하는 언어라는 인식이 강했고 실제로 그랬습니다. 웹 시장이 커질 때 동적 페이지를 다루기 위해 HTML내의 <script> 태그로 삽입하여 주로 사용했습니다. 자바가 인기를 얻으면서 이름이 비슷한 것도 입소문을 내기에 좋았습니다. 하지만 브라우저에 삽입된 소스코드가 그대로 노출되고 보안에 취약하다는 인식이 있었고 사용은 많이 하지만 "그냥 스크립트 언어"라는 괄시를 받았습니다. 이후 Node.js의 등장으로 자바스크립트를 이용하여 서버를 구동할 수 있게 되었습니다. 프론트엔드와 백엔드에서 같은 언어를 사용한다는 것은 큰 장점입니다. 같은 개발자가 풀스택2으로 개발할 경우 생산성을 향상시켜주고, 프론트엔드/백엔드가 분리되어 있다 하더라도 커뮤니케이션 비용을 줄여줍니다. Node.js의 등장으로 자바스크립트는 당당히 하나의 언어로 인정받게 되었습니다. 2008년 구글은 크롬 브라우저를 출시하면서 자체 개발한 자바스크립트 엔진인 V8을 크롬에 내장하였습니다. V8의 뛰어난 성능은 "자바스크립트는 느리다"는 인식을 바꾸어 주었습니다.

Node.js는 NPM(Node Package Manager)이라고 하는 패키지(또는 라이브러리) 관리 시스템을 가지고 있습니다. 누구나 자신이 만든 Node.js 기반 라이브러리를 등록하여 다른 사람들이 사용하게 공개할 수 있습니다. 공개하기는 싫지만 NPM을 이용하여 사내에서 패키지를 관리하고자 한다면 돈을 지불하고 비공개(Private)로 등록도 가능합니다. NPM 블로그에 따르면 2022년 3월 현재 등록된 패키지 수가 190만개에 다다르고 있습니다3. 대부분의 소스코드가 깃허브에 공개되고 있는데 깃허브는 2020년 3월 NPM을 인수하였습니다. 마이크로소프트가 깃허브를 인수하였으므로 사실상 NPM은 마이크로소프트가 주도하게 되었습니다. Nest 역시 Node.js를 기반으로 하므로 NPM을 그대로 사용할 수 있습니다. 개발에 필요한 라이브러리가 있다면 NPM CLI를 이용하여 설치하면 됩니다. 심지어 Nest 역시 NPM에 등록되어 있고 1장에서 본 것 처럼 NPM으로 설치합니다. Nest 관련 패키지들을 확인하고 싶다면 npmjs.com에서 @nestjs 로 검색해 보세요.
## Node.js의 특징
### 단일 쓰레드에서 구동되는 non-blocking I/O 이벤트 기반 비동기 방식
작업 요청이 한꺼번에 들어올 때 각 작업을 처리하기 위한 쓰레드를 만들고 할당하는 방식을 멀티 쓰레드 방식이라고 합니다. 멀티 쓰레드 방식은 여러 작업을 동시에 처리하므로 작업 처리속도가 빠른 장점이 있지만, 공유 자원을 관리하는 노력이 많이 들고 잘못 작성된 동기화로 인해 락에서 빠져나오지 못하는 경우가 발생하기 쉽습니다. 쓰레드가 늘어날 때 마다 메모리를 소모하게 되므로 메모리 관리 역시 중요합니다. 이에 비해 Node.js는 하나의 쓰레드에서 작업을 처리합니다. 사실 애플리케이션 단에서는 단일 쓰레드이지만 백그라운에서는 쓰레드 풀을 구성해 작업을 처리합니다. 개발자가 직접 쓰레드 풀을 관리하지 않고 플랫폼, 정확히는 Node.js에 포함된 libuv5가 그 역할을 하기 때문에 개발자는 단일 쓰레드에서 동작하는 것처럼 이해하기 쉬운 코드를 작성할 수 있습니다. 웹 서버를 운용할 때는 코어(CPU)를 분산해서 관리하므로 실제 작업은 여러개의 코어에서 별개로 처리됩니다.

Node.js는 이렇게 들어온 작업을 앞의 작업이 끝날때까지 기다리지 않고(non-blocking) 비동기로 처리합니다. 이 개념을 쉽게 설명하면 다음과 같습니다. 푸드코트의 경우 주문은 한 곳에서 받지만 음식은 입점된 각 식당에서 만듭니다. 음식이 완성된 순서대로 각 식당에서 호출벨을 통해 손님을 부르고 손님은 음식을 픽업합니다. 여기서 계산을 담당하는 작업은 단일 쓰레드이고 각 요리를 완성해 벨을 호출하는 식당들은 비동기로 요리를 준비합니다. 입력은 하나의 쓰레드에서 받지만 순서대로 처리 하지 않고 먼저 처리된 결과를 이벤트로 반환해주는 방식이 바로 Node.js가 사용하는 단일 쓰레드 non-blocking 이벤트 기반 비동기 방식입니다.

### Node.js의 장단점
앞에서 설명한 단일 쓰레드 이벤트 기반 비동기 방식은 서버의 자원에 크게 부하를 가하지 않습니다. 이는 대규모 네트워크 애플리케이션을 개발하기에 적합합니다. 물론 쓰레드를 하나만 사용하기 때문에 하나의 쓰레드에 문제가 생기게 되면 애플리케이션 전체가 오류를 일으킬 위험이 있습니다. 하나의 쓰레드로 동작하는 것처럼 코드를 작성할 수 있다는 점은 개발자에게 큰 장점입니다. 멀티 쓰레드를 직접 만들고 관리하면서 데드락에 빠져 본 분들은 그 어려움을 공감하실 것입니다.

Node.js의 단점은 아무래도 컴파일러 언어의 처리속도에 비해 그 성능이 떨어진다는 점입니다. 하지만 서버의 성능은 꾸준히 발전하고 있고, V8엔진의 성능이 계속 향상되고 있어 왠만한 웹 애플리케이션을 만들기에는 손색이 없습니다. 이벤트 기반 비동기 방식으로 복잡한 기능을 구현하다 보면 여러 이벤트를 동시에 처리하는 경우 콜백 지옥에 빠지는 경우가 있습니다. 코드가 대각선으로 쭉 들어쓰여 작성되면서 가독성이 떨어지고 이해하기 어려운 코드가 양산되는 경우가 빈번했습니다. 하지만 ECMAScript 2015(ES6)에서 Promise가 도입되면서 간결한 표현으로 작성할 수 있게 되었습니다. ECMAScript 2017에서는 async/await 기능이 추가되면서 비동기 동작을 마치 동기로 처리하는 것처럼 코드를 작성할 수 있게 되었습니다.
  
## 2.3 이벤트 루프
이벤트 루프에는 6개의 단계(Phase)가 있습니다. 아래 그림의 루프를 이루고 있는 부분에서 네모박스로 표시된 것들입니다. 각 단계는 단계마다 처리해야 하는 콜백 함수를 담기 위한 큐를 가지고 있습니다. 화살표는 각 단계가 전이되는 방향을 뜻하지만 이후에 설명하듯 반드시 다음 단계로 넘어가는 것은 아닙니다. 자바스크립트 코드는 idle & prepare 단계를 제외한 어느 단계에서나 실행될 수 있습니다. nextTickQueue와 microTaskQueue는 이벤트 루프의 구성요소는 아니고 이 큐에 들어 있는 작업 역시 이벤트 루프가 어느 단계에 있든지 실행될 수 있습니다. node main.js 명령어로 Node.js 애플리케이션을 콘솔에서 실행하면 Node.js는 먼저 이벤트 루프를 생성한 다음 메인 모듈인 main.js를 실행합니다. 이 과정에서 생성된 콜백들이 각 단계에 존재하는 큐에 들어가게 되는데 메인 모듈의 실행을 완료한 다음 이벤트 루프를 계속 실행할 지 결정합니다. 만약 큐가 모두 비어서 더 이상 수행할 작업이 없다면 Node.js는 루프를 빠져나가고 프로세스를 종료합니다.
  
![image](https://user-images.githubusercontent.com/87610758/175562241-d69971d0-9a2a-4f1b-9708-ead5ccac49e4.png)

### Timer 단계
이벤트 루프는 Timer 단계에서 시작합니다. Timer 단계의 큐에는 setTimeout이나 setInterval과 같은 함수를 통해 만들어진 타이머들을 큐에 넣고 실행합니다. now - registeredTime ≥ delta 인 값을 가지는 타이머들이 큐에 들어갑니다. 여기서 delta는 setTimeout(() => {}, delta)과 같이 타이머가 등록된 시각에서 얼마만큼 시간이 흐른후에 동작해야 하는 지를 나타내는 값입니다. 즉, 대상 타이머들은 이미 실행할 시간이 같거나 지났다는 뜻입니다. 타이머들은 최소 힙1으로 관리됩니다. 힙을 구성할 때 기준으로 실행할 시각이 가장 적게 남은 타이머가 힙의 루트가 됩니다. Timer 단계에서 최소 힙에 들어 있는 타이머들을 순차적으로 찾아 실행한 후 힙을 재구성합니다.

예를 들어 딜레이 값이 100, 200, 300, 400인 4개의 타이머(A, B, C, D)를 특정 시간 t에 힙에 등록했다고 가정해보겠습니다. 최소 힙은 A → B → C → D의 순으로 순회할 수 있도록 구성됩니다. 이제 이벤트 루프가 t+250 시각에 Timer 단계에 진입했다고 한다면, 힙에서 순차적으로 A, B, C, D 순으로 꺼내어 시간을 비교합니다. A, B는 이미 250만큼의 시간이 지났기 때문에 둘의 콜백은 수행이 되지만, C는 아직 시간이 지나지 않았기 때문에 실행되지 않습니다. D는 최소 힙의 특성상 C를 이미 실행하지 않기로 했기 때문에 비교할 필요가 없습니다. 그리고 시간이 지난 타이머들의 콜백이 무한정 실행되는 것은 아니고 시스템의 실행 한도(Hard Limit)에 도달하면 다음 단계로 넘어갑니다.

### Pending (i/o) 콜백 단계
이 단계의 큐에 들어있는 콜백들은 현재 돌고 있는 루프 이전의 작업에서 큐에 들어온 콜백입니다. 예를 들어 TCP 핸들러 내에서 비동기의 쓰기 작업을 한다면, TCP 통신과 쓰기 작업이 끝난 후 해당 작업의 콜백이 큐에 들어옵니다. 또 에러 핸들러 콜백도 pending_queue로 들어오게 됩니다.

Timer 단계를 거쳐 pending 콜백 단계에 들어오면 이전 작업들의 콜백이 pending_queue에서 대기중인지를 검사합니다. 만약 실행 대기 중이라면 시스템 실행 한도에 도달할 때까지 꺼내어 실행합니다.

### Idle, Prepare 단계
Idle 단계는 매 틱(Tick, 매 단계가 이동하는 것을 의미함)마다 실행됩니다. Prepare 단계는 매 폴링마다 그 전에 실행됩니다. 이 두 단계는 Node.js의 내부 동작을 위한 것입니다.

### Poll 단계
이벤트 루프 중 가장 중요한 단계입니다. Poll 단계에서는 새로운 I/O 이벤트를 가져와서 관련 콜백을 수행합니다. 예를 들어 소켓 연결과 같은 새로운 커넥션을 맺거나 파일 읽기와 같이 데이터 처리를 받아들이게 됩니다. 이 단계가 가지고 있는 큐는 watch_queue입니다. 이 단계에 진입한 후 watch_queue가 비어 있지 않다면 큐가 비거나 시스템 실행 한도에 다다를 때까지 동기적으로 모든 콜백을 실행합니다. 만약 큐가 비게되면 Node.js는 곧바로 다음 단계로 이동하지 않고 check_queue(Check 단계의 큐), pending_queue(Pending 콜백 단계의 큐), closing_callbacks_queue(Close 콜백 단계의 큐)에 남은 작업이 있는지 검사한 다음 작업 있다면 다음 단계로 이동합니다. 만약 큐가 모두 비어서 해야할 작업이 없다면 잠시 대기를 하게 됩니다. 이때 대기시간은 타이머 최소 힙의 첫번째 타이머를 꺼내어 지금 실행할 수 있는 상태라면 그 시간만큼 대기한 후 다음 단계로 이동합니다. 이렇게 하는 이유는 바로 타이머 단계로 넘어간다고 해도 어차피 첫번째 타이머를 수행할 시간이 되지 않았기 때문에 이벤트 루프를 한 번 더 돌아야 하므로 Poll 단계에서 시간을 보내는 것입니다.

### Check 단계
Check 단계는 setImmediate의 콜백만을 위한 단계입니다. 역시 큐가 비거나 시스템 실행 한도에 도달할 때 까지 콜백을 수행합니다.

### Close 콜백 단계
socket.on('close', () => {})과 같은 close나 destroy 이벤트 타입의 콜백이 여기서 처리됩니다. 이벤트 루프는 Close 콜백 단계를 마치고 나면 다음 루프에서 처리해야 하는 작업이 남아 있는지 검사합니다. 만약 작업이 남아 있다면 Timer 단계부터 한 번 더 루프를 돌게 되고 아니라면 루프를 종료합니다.

nextTickQueue과 microTaskQueue
nextTickQueue는 process.nextTick() API의 콜백들을 가지고 있으며, microTaskQueue는 Resolve된 Promise의 콜백을 가지고 있습니다. 이 두개의 큐는 기술적으로 이벤트 루프의 일부가 아닙니다. 즉, libuv 라이브러리에 포함된 것이 아니라 Node.js에 포함된 기술입니다. 이 두 큐에 들어 있는 콜백은 단계를 넘어가는 과정에서 먼저 실행됩니다. nextTickQueue가 microTaskQueue보다 높은 우선순위를 가지고 있습니다.
